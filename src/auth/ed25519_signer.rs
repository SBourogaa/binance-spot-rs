use anyhow::Context;
use async_trait::async_trait;
use base64::prelude::{BASE64_STANDARD, Engine};
use ed25519_dalek::pkcs8::DecodePrivateKey;
use ed25519_dalek::{Signature, Signer, SigningKey};
use zeroize::ZeroizeOnDrop;

use crate::Result;
use crate::{auth::SignatureProvider, errors::InvalidCredentials};

/**
 * Ed25519 signature provider for Binance API authentication with secure key management.
 *
 * This implementation provides Ed25519 digital signatures with automatic memory
 * cleanup to prevent key material from lingering in memory.
 *
 * # Fields
 * - `api_key`: The API key for request headers.
 * - `signing_key`: The Ed25519 private key for generating signatures.
 */
#[derive(Debug, ZeroizeOnDrop)]
pub struct Ed25519Signer {
    #[zeroize(skip)] // Don't zeroize as SigningKey handles its own secure cleanup
    api_key: String,
    signing_key: SigningKey,
}

impl Ed25519Signer {
    /**
     * Creates a new Ed25519 signer from API key and PEM-encoded private key.
     *
     * The private key should be in PKCS#8 PEM format as generated by OpenSSL or
     * other standard cryptographic tools.
     *
     * # Arguments
     * - `api_key`: The Binance API key for request authentication.
     * - `private_key_pem`: PEM-encoded Ed25519 private key string.
     *
     * # Returns
     * - `Self`: New Ed25519Signer instance.
     */
    pub fn new(api_key: impl Into<String>, private_key_pem: &str) -> Result<Self> {
        // Parse PKCS#8 PEM format using ed25519-dalek's built-in support
        let signing_key = SigningKey::from_pkcs8_pem(private_key_pem)
            .map_err(|e| InvalidCredentials::invalid_private_key(format!("{}", e)))?;

        Ok(Self {
            api_key: api_key.into(),
            signing_key,
        })
    }

    /**
     * Creates a new Ed25519 signer by loading from file path.
     *
     * # Arguments
     * - `api_key`: The Binance API key for request authentication.
     * - `file_path`: Path to PEM file containing Ed25519 private key.
     *
     * # Returns
     * - `Self`: New Ed25519Signer instance.
     */
    pub fn from_pem_file(api_key: impl Into<String>, file_path: &str) -> Result<Self> {
        let pem_contents = std::fs::read_to_string(file_path)
            .with_context(|| format!("Failed to read PEM file '{}'", file_path))?;

        Self::new(api_key, &pem_contents)
    }

    /**
     * Securely rotates the signing key while keeping the same API key.
     *
     * This method allows for key rotation without recreating the entire signer.
     * The old key material is automatically zeroized.
     *
     * # Arguments
     * - `new_private_key_pem`: New PEM-encoded Ed25519 private key string.
     *
     * # Returns
     * - `()`: Success.
     */
    pub fn rotate_key(&mut self, new_private_key_pem: &str) -> Result<()> {
        let new_signing_key = SigningKey::from_pkcs8_pem(new_private_key_pem)
            .map_err(|e| InvalidCredentials::invalid_private_key(format!("{}", e)))?;

        // Replace the key - old key is automatically dropped and zeroized
        self.signing_key = new_signing_key;
        Ok(())
    }

    /**
     * Rotates the signing key from a new PEM file.
     *
     * # Arguments
     * - `file_path`: Path to PEM file containing new Ed25519 private key.
     *
     * # Returns
     * - `()`: Success.
     */
    pub fn rotate_key_from_file(&mut self, file_path: &str) -> Result<()> {
        let pem_contents = std::fs::read_to_string(file_path)
            .with_context(|| format!("Failed to read new PEM file '{}'", file_path))?;

        self.rotate_key(&pem_contents)
    }
}

#[async_trait]
impl SignatureProvider for Ed25519Signer {
    fn get_api_key(&self) -> &str {
        &self.api_key
    }

    async fn sign(&self, payload: &str) -> Result<String> {
        let signature: Signature = self.signing_key.sign(payload.as_bytes());
        let signature_b64 = BASE64_STANDARD.encode(signature.to_bytes());

        Ok(signature_b64)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::auth::SignatureProvider;
    use proptest::prelude::*;
    use std::sync::Arc;

    const TEST_ED25519_PEM: &str = r#"-----BEGIN PRIVATE KEY-----
MC4CAQAwBQYDK2VwBCIEIC8tLOD+n4yj+ER4J+9+4B+8l7pK5J+yX9CX7V3c7z6S
-----END PRIVATE KEY-----"#;

    const TEST_API_KEY: &str = "test_api_key_ed25519";

    /**
     * Tests key rotation maintains API key while changing signatures appropriately.
     */
    #[tokio::test]
    async fn test_key_rotation_behavior() {
        // Arrange
        let mut signer = Ed25519Signer::new(TEST_API_KEY, TEST_ED25519_PEM)
            .expect("Signer creation should succeed");
        let payload = "test_payload";

        // Act
        let original_sig = signer
            .sign(payload)
            .await
            .expect("Original signing should work");
        signer
            .rotate_key(TEST_ED25519_PEM)
            .expect("Key rotation should succeed");
        let same_key_sig = signer
            .sign(payload)
            .await
            .expect("Signing after same-key rotation should work");

        // Assert
        assert_eq!(
            signer.get_api_key(),
            TEST_API_KEY,
            "API key should remain unchanged"
        );
        assert_eq!(
            original_sig, same_key_sig,
            "Same key should produce same signature"
        );
    }

    /**
     * Tests concurrent signing operations are thread-safe.
     */
    #[tokio::test]
    async fn test_concurrent_signing_safety() {
        // Arrange
        let signer = Arc::new(
            Ed25519Signer::new(TEST_API_KEY, TEST_ED25519_PEM)
                .expect("Signer creation should succeed"),
        );
        let mut handles = Vec::new();

        // Act
        for i in 0..10 {
            let signer_clone = Arc::clone(&signer);
            let payload = format!("symbol=BTCUSDT&nonce={}", i);

            let handle = tokio::spawn(async move { signer_clone.sign(&payload).await });

            handles.push(handle);
        }

        // Assert
        for handle in handles {
            let result = handle.await.expect("Task should complete");
            assert!(result.is_ok(), "Concurrent signing should succeed");

            let signature = result.unwrap();
            let decoded = BASE64_STANDARD
                .decode(&signature)
                .expect("Should be valid base64");
            assert_eq!(decoded.len(), 64, "Should produce valid 64-byte signature");
        }
    }

    /**
     * Tests SignatureProvider trait implementation works correctly.
     */
    #[tokio::test]
    async fn test_signature_provider_trait() {
        // Arrange
        let signer: Box<dyn SignatureProvider> = Box::new(
            Ed25519Signer::new(TEST_API_KEY, TEST_ED25519_PEM)
                .expect("Signer creation should succeed"),
        );
        let payload = "symbol=ADAUSDT&side=BUY&timestamp=1111111111";

        // Act
        let api_key = signer.get_api_key();
        let signature_result = signer.sign(payload).await;

        // Assert
        assert_eq!(api_key, TEST_API_KEY);
        assert!(signature_result.is_ok(), "Trait object signing should work");
    }

    /**
     * Tests rejection of invalid PEM data.
     */
    #[tokio::test]
    async fn test_invalid_pem_rejection() {
        // Arrange
        let invalid_cases = vec![
            "",
            "not a pem at all",
            "-----BEGIN INVALID-----\ngarbage\n-----END INVALID-----",
            "-----BEGIN PRIVATE KEY-----\ninvalid_base64_!@#$\n-----END PRIVATE KEY-----",
        ];

        // Act & Assert
        for invalid_pem in invalid_cases {
            let result = Ed25519Signer::new(TEST_API_KEY, invalid_pem);

            assert!(
                result.is_err(),
                "Should reject invalid PEM: {}",
                invalid_pem
            );

            // Since we're using anyhow::Result, check the error chain
            let error = result.unwrap_err();
            let error_chain = format!("{:#}", error);
            assert!(
                error_chain.contains("private key format is invalid")
                    || error_chain.contains("Invalid credentials"),
                "Should mention credential/key validation failure, got: {}",
                error_chain
            );
        }
    }

    // Property-based tests
    proptest! {
        /**
         * Property test: Ed25519 signing is deterministic and produces valid signatures.
         */
        #[test]
        fn prop_signature_determinism_and_validity(
            payload in ".*", // Any string
        ) {
            // Arrange
            let signer = Ed25519Signer::new(
                TEST_API_KEY,
                TEST_ED25519_PEM
            ).unwrap();

            // Act
            let sig1 = futures::executor::block_on(signer.sign(&payload)).unwrap();
            let sig2 = futures::executor::block_on(signer.sign(&payload)).unwrap();
            let decoded = BASE64_STANDARD.decode(&sig1).unwrap();

            // Assert
            prop_assert_eq!(sig1, sig2);
            prop_assert_eq!(decoded.len(), 64);
        }

        /**
         * Property test: Different payloads produce different signatures (collision resistance).
         */
        #[test]
        fn prop_collision_resistance(
            payload1 in "[a-zA-Z0-9=&]{10,100}",
            payload2 in "[a-zA-Z0-9=&]{10,100}",
        ) {
            prop_assume!(payload1 != payload2);

            // Arrange
            let signer = Ed25519Signer::new(
                TEST_API_KEY,
                TEST_ED25519_PEM
            ).unwrap();

            // Act
            let sig1 = futures::executor::block_on(signer.sign(&payload1)).unwrap();
            let sig2 = futures::executor::block_on(signer.sign(&payload2)).unwrap();

            // Assert
            prop_assert_ne!(sig1, sig2);
        }

        /**
         * Property test: Realistic Binance API payloads are handled correctly.
         */
        #[test]
        fn prop_binance_api_compatibility(
            symbol in "[A-Z]{3,8}[A-Z]{3,8}",
            side in "(BUY|SELL)",
            timestamp in 1000000000000u64..2000000000000u64,
            price_str in "0\\.[0-9]{1,8}|[1-9][0-9]{0,5}\\.[0-9]{1,8}",
            qty_str in "0\\.[0-9]{1,8}|[1-9][0-9]{0,3}\\.[0-9]{1,8}",
        ) {
            // Arrange
            let payload = format!(
                "symbol={}&side={}&type=LIMIT&timeInForce=GTC&quantity={}&price={}&timestamp={}",
                symbol, side, qty_str, price_str, timestamp
            );
            let signer = Ed25519Signer::new(
                TEST_API_KEY,
                TEST_ED25519_PEM
            ).unwrap();

            // Act
            let result = futures::executor::block_on(signer.sign(&payload));

            // Assert
            prop_assert!(result.is_ok());
            let signature = result.unwrap();
            let decoded = BASE64_STANDARD.decode(&signature).unwrap();
            prop_assert_eq!(decoded.len(), 64);
        }
    }
}
